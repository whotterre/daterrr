// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: swipe.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const checkMutualSwipe = `-- name: CheckMutualSwipe :one
SELECT EXISTS (
    SELECT 1 FROM swipes 
    WHERE 
        swiper_id = $1 AND  -- The other user
        swipee_id = $2      -- Current user
) AS is_mutual
`

type CheckMutualSwipeParams struct {
	SwiperID pgtype.UUID `json:"swiper_id"`
	SwipeeID pgtype.UUID `json:"swipee_id"`
}

func (q *Queries) CheckMutualSwipe(ctx context.Context, arg CheckMutualSwipeParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkMutualSwipe, arg.SwiperID, arg.SwipeeID)
	var is_mutual bool
	err := row.Scan(&is_mutual)
	return is_mutual, err
}

const createMatch = `-- name: CreateMatch :one
WITH new_match AS (
  INSERT INTO matches (user1_id, user2_id) --swipee_id, swipee_id
  VALUES (
    LEAST($1::uuid, $2::uuid),
    GREATEST($1::uuid, $2::uuid)
  )
  ON CONFLICT (user1_id, user2_id) DO NOTHING
  RETURNING id, user1_id, user2_id, matched_at
)
INSERT INTO chats (user1_id, user2_id)
SELECT user1_id, user2_id FROM new_match
ON CONFLICT (user1_id, user2_id) DO NOTHING
RETURNING (SELECT id FROM new_match)
`

type CreateMatchParams struct {
	Column1 pgtype.UUID `json:"column_1"`
	Column2 pgtype.UUID `json:"column_2"`
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createMatch, arg.Column1, arg.Column2)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const findExistingMatch = `-- name: FindExistingMatch :one
SELECT id FROM matches 
WHERE user1_id = $1 AND user2_id = $2
LIMIT 1
`

type FindExistingMatchParams struct {
	User1ID pgtype.UUID `json:"user1_id"`
	User2ID pgtype.UUID `json:"user2_id"`
}

func (q *Queries) FindExistingMatch(ctx context.Context, arg FindExistingMatchParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, findExistingMatch, arg.User1ID, arg.User2ID)
	var id pgtype.UUID
	err := row.Scan(&id)
	return id, err
}

const generateFeed = `-- name: GenerateFeed :many
SELECT 
  u.id,
  u.email,
  u.created_at,
  u.last_active,
  p.first_name,
  p.last_name,
  p.bio,
  p.gender,
  p.age,
  p.image_url,
  p.interests,
  p.location
FROM users u
JOIN profiles p ON u.id = p.user_id
WHERE u.id != $1
LIMIT 10
`

type GenerateFeedRow struct {
	ID         pgtype.UUID      `json:"id"`
	Email      string           `json:"email"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	LastActive pgtype.Timestamp `json:"last_active"`
	FirstName  string           `json:"first_name"`
	LastName   string           `json:"last_name"`
	Bio        pgtype.Text      `json:"bio"`
	Gender     string           `json:"gender"`
	Age        int32            `json:"age"`
	ImageUrl   pgtype.Text      `json:"image_url"`
	Interests  []string         `json:"interests"`
	Location   pgtype.Point     `json:"location"`
}

func (q *Queries) GenerateFeed(ctx context.Context, id pgtype.UUID) ([]GenerateFeedRow, error) {
	rows, err := q.db.Query(ctx, generateFeed, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GenerateFeedRow{}
	for rows.Next() {
		var i GenerateFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.CreatedAt,
			&i.LastActive,
			&i.FirstName,
			&i.LastName,
			&i.Bio,
			&i.Gender,
			&i.Age,
			&i.ImageUrl,
			&i.Interests,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newSwipe = `-- name: NewSwipe :exec
INSERT INTO swipes (swiper_id, swipee_id) VALUES(
    $1, $2 -- Swiper ID and Swipee ID
) ON CONFLICT (swiper_id, swipee_id) DO NOTHING
`

type NewSwipeParams struct {
	SwiperID pgtype.UUID `json:"swiper_id"`
	SwipeeID pgtype.UUID `json:"swipee_id"`
}

// Handle swipes
func (q *Queries) NewSwipe(ctx context.Context, arg NewSwipeParams) error {
	_, err := q.db.Exec(ctx, newSwipe, arg.SwiperID, arg.SwipeeID)
	return err
}
