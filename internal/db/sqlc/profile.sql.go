// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: profile.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteUserWithProfile = `-- name: DeleteUserWithProfile :one
WITH deleted_user AS (
  DELETE FROM users WHERE users.id = $1
  RETURNING id, email, created_at
),
deleted_profile AS (
  DELETE FROM profiles WHERE user_id = $1
  RETURNING id, user_id, first_name, last_name, bio, gender, age, image_url, location, interests
)
SELECT 
  du.id AS user_id,
  du.email,
  du.created_at AS user_created_at,
  dp.first_name,
  dp.last_name,
  dp.gender,
  dp.age,
  dp.image_url
FROM deleted_user du
LEFT JOIN deleted_profile dp ON true
`

type DeleteUserWithProfileRow struct {
	UserID        pgtype.UUID      `json:"user_id"`
	Email         string           `json:"email"`
	UserCreatedAt pgtype.Timestamp `json:"user_created_at"`
	FirstName     pgtype.Text      `json:"first_name"`
	LastName      pgtype.Text      `json:"last_name"`
	Gender        pgtype.Text      `json:"gender"`
	Age           pgtype.Int4      `json:"age"`
	ImageUrl      pgtype.Text      `json:"image_url"`
}

// Delete user and profile with confirmation
func (q *Queries) DeleteUserWithProfile(ctx context.Context, id pgtype.UUID) (DeleteUserWithProfileRow, error) {
	row := q.db.QueryRow(ctx, deleteUserWithProfile, id)
	var i DeleteUserWithProfileRow
	err := row.Scan(
		&i.UserID,
		&i.Email,
		&i.UserCreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.Gender,
		&i.Age,
		&i.ImageUrl,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password FROM users
WHERE email = $1
LIMIT 1
`

type GetUserByEmailRow struct {
	ID       pgtype.UUID `json:"id"`
	Email    string      `json:"email"`
	Password string      `json:"password"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (GetUserByEmailRow, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(&i.ID, &i.Email, &i.Password)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
  id, 
  email, 
  created_at,
  last_active
FROM users 
WHERE id = $1
LIMIT 1
`

type GetUserByIDRow struct {
	ID         pgtype.UUID      `json:"id"`
	Email      string           `json:"email"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	LastActive pgtype.Timestamp `json:"last_active"`
}

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (GetUserByIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i GetUserByIDRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.LastActive,
	)
	return i, err
}

const getUserProfile = `-- name: GetUserProfile :one
SELECT 
  u.id,
  u.email,
  u.created_at,
  u.last_active,
  p.first_name,
  p.last_name,
  p.bio,
  p.gender,
  p.age,
  p.image_url,
  p.interests,
  p.location
FROM users u
JOIN profiles p ON u.id = p.user_id
WHERE u.id = $1
LIMIT 1
`

type GetUserProfileRow struct {
	ID         pgtype.UUID      `json:"id"`
	Email      string           `json:"email"`
	CreatedAt  pgtype.Timestamp `json:"created_at"`
	LastActive pgtype.Timestamp `json:"last_active"`
	FirstName  string           `json:"first_name"`
	LastName   string           `json:"last_name"`
	Bio        pgtype.Text      `json:"bio"`
	Gender     string           `json:"gender"`
	Age        int32            `json:"age"`
	ImageUrl   pgtype.Text      `json:"image_url"`
	Interests  []string         `json:"interests"`
	Location   pgtype.Point     `json:"location"`
}

// Get complete user profile by ID
func (q *Queries) GetUserProfile(ctx context.Context, id pgtype.UUID) (GetUserProfileRow, error) {
	row := q.db.QueryRow(ctx, getUserProfile, id)
	var i GetUserProfileRow
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.CreatedAt,
		&i.LastActive,
		&i.FirstName,
		&i.LastName,
		&i.Bio,
		&i.Gender,
		&i.Age,
		&i.ImageUrl,
		&i.Interests,
		&i.Location,
	)
	return i, err
}

const updateLastActive = `-- name: UpdateLastActive :exec
UPDATE users
SET last_active = now()
WHERE id = $1
`

func (q *Queries) UpdateLastActive(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateLastActive, id)
	return err
}

const updateProfile = `-- name: UpdateProfile :one
UPDATE profiles
SET 
  first_name = COALESCE($2, first_name),
  last_name = COALESCE($3, last_name),
  bio = COALESCE($4, bio),
  image_url = COALESCE($5, image_url),
  interests = COALESCE($6, interests),
  location = COALESCE(ST_SetSRID(ST_MakePoint($7, $8), 4326), location)
WHERE user_id = $1
RETURNING id, user_id, first_name, last_name, bio, gender, age, image_url, location, interests
`

type UpdateProfileParams struct {
	UserID        pgtype.UUID `json:"user_id"`
	FirstName     string      `json:"first_name"`
	LastName      string      `json:"last_name"`
	Bio           pgtype.Text `json:"bio"`
	ImageUrl      pgtype.Text `json:"image_url"`
	Interests     []string    `json:"interests"`
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (Profile, error) {
	row := q.db.QueryRow(ctx, updateProfile,
		arg.UserID,
		arg.FirstName,
		arg.LastName,
		arg.Bio,
		arg.ImageUrl,
		arg.Interests,
		arg.StMakepoint,
		arg.StMakepoint_2,
	)
	var i Profile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FirstName,
		&i.LastName,
		&i.Bio,
		&i.Gender,
		&i.Age,
		&i.ImageUrl,
		&i.Location,
		&i.Interests,
	)
	return i, err
}

const userExists = `-- name: UserExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)
`

func (q *Queries) UserExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, userExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
